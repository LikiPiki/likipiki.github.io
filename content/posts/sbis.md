---
title: "Проектирование СБИС, вопросы и ответы"
date: 2021-01-01T11:19:53Z
draft: false
authors: ["likipiki"]
toc: true
katex: true
categories:
  - others
tags:
  - study
---

# Проектирование СБИС

> Часть билетов уже готова, еще часть осталась, можете брать и редактировать этот документ распределив вопросы. Хорошо было бы прочитать это все целиком, и исправить неточности и добавить того что было на лекциях.

**Готовые билеты: 1, 4, 27, 28, 35, 36, 38, 39**

## 1. Области представления СБИС, диаграмма Гайского-канна
В зависимости от взглядов на природу ЦУ (цифрового устройства) и его организацию, принято рассматривать три области представления: физическая, структурная и поведенческая, которые показаны на рисунках . Для каждой из этих областей различают различные уровни:
1. схемный
2. логический
3. языков регистровых передач (ЯРП)
4. системный.

При этом в поведенческой области дается функциональное представление ЦУ, в структурной области описываются блоки архитектуры ДУ, физическая область отражает реальный кристалл (chip).

![](https://i.imgur.com/ROfCuhp.png)

![](https://i.imgur.com/Nnn8gw4.png)

Синтез ЦУ сводится к процессу трансформации проекта от верхнего уровня абстракции к нижнему уровню. Процесс проектирования ЦУ на приведенной диаграмме можно отразить в виде последовательного спуска по уровням абстракции по каждой из областей представления. Но спуск по уровням в любой области связан и чередуется с движением по оси иерархии остальных областей. При этом по уровневый характер внутри любой области сочетается с согласованным движением по осям остальных областей. Этот путь состоит из нескольких переходов от одного уровня к другому в одной и той же области; переходе от одной области к другой на том же уровне и оптимизации на любом участке пути. Преобразования носят характер "от нескольких ко многим", что, например, означает существование нескольких структурных реализаций для каждого поведенческого представления и еще больше физических конфигураций для каждой структурной модели.

![](https://i.imgur.com/Uvg4FCM.png)

Переходы, показанные на рисунке представляют различные задачи, решаемые при проектировании. На этой модели синтез соответствует переходу от поведенческой к структурной области. Петля в этом случае соответствует оптимизации на одном и том же уровне. Переход от структурной к физической области соответствует генерации маски (размещения и трассировки), в то время как обратный переход – процессу выделения параметров. При этом из подложки определяются электрические параметры, которые включаются в структурную область для точного моделирования на поведенческом уровне.

На рисунке ниже показаны различные процессы, имеющие место при высокоуровневом синтезе. Дуга 1а переводит различные операции в конкретные подсистемы, процессоры и т.п. Дуга 1b дает описание на уровне ЯРП. ЯРП синтез представлен дугами 2a, 2b, 2c . При этом на шаге 2c выполняется на вентильном уровне оптимизация схемы по некоторым критериям, таким число вентилей, пересечений и т.п. Дуга 3с представляет технологическое отображение. Соответственно 4a и 4b соответствуют логическому синтезу и оптимизации. Остальные дуги 5a, 5b, 5c относятся к физическому синтезу, где генерируются маски. При проектировании на стандартных ячейках достаточно выполнить 5a. Однако, системы на кристалле содержат ядра (cores), что требует привлечения 5с в зависимости от типа ядра.

![](https://i.imgur.com/1fZwaMl.png)


## 2. Организация процесса проектирования, этапы разработки проекта СБИС
## 3. Языки описания аппаратуры, области их применения
Язык описания аппаратуры (HDL от англ. hardware description language) — специализированный компьютерный язык, используемый для описания структуры и поведения электронных схем, чаще всего цифровых логических схем.

Языки описания аппаратуры внешне похожи на такие языки программирования, как Си или Паскаль, написанные на них программы также состоят из выражений, операторов, управляющих структур. Важнейшим отличием между обычными языками программирования и языками HDL является явное включение концепции времени в языки описания аппаратуры.

Языки описания аппаратуры являются неотъемлемой частью САПР (система автоматического проектирования), особенно для таких сложных схем, как специализированные интегральные схемы, микропроцессоры и программируемые логические устройства.

Основные практически используемые языки описания аппаратуры --- Verilog и VHDL. Изначально как Verilog, так и VHDL использовались для документирования и моделирования схемных решений, реализованных в иной форме (например, в виде схем). Моделирование при помощи HDL позволило инженерам работать на более высоком уровне абстракции, чем моделирование на уровне схемы, и, следовательно, упростить моделирование проектов, состоящих из тысяч транзисторов и более.

Введение логического синтеза схем из HDL сделало их основным языком для создания цифровых схем. САПР синтеза компилируют исходные файлы (написанные на подмножестве HDL, называемом RTL — англ. Register transfer level — Уровень регистровых передач) в описание схемы в форме списков связей (netlist, задающих соединения вентилей и транзисторов. Написание синтезируемого RTL-кода требует практики и соблюдения ряда правил со стороны разработчика. По сравнению с традиционным проектированием схем, создание синтезируемого RTL менее трудоёмко, но зачастую приводит к несколько большим по площади и менее производительным схемам.
## 4. Языки описания аппаратуры, причины возникновения
Аналогичный предыдущему вопросу.

**Причины:**
1. Можно сделать логику не проектирую СБИС на железе.
2. Большие возможности моделирования и симуляции схем.

## 5. Производственный процесс. Понятие проектной нормы
## 6. Способы ускорения процесса разработки СБИС
## 7. Понятие повторно используемых компонентов. Причины возникновения.
## 8. Полностью заказные СБИС
## 9. Базовые матричные кристаллы
## 10. Сравнение характеристик полностью заказных СБИС и БМК
## 11. Программируемые логические матрицы
## 12. Понятие CPLD
## 13. Понятие FPGA
FPGA --- (Field-Programmable Gate Array), то есть программируемая логическая матрица (ПЛМ), программируемая логическая интегральная схема (ПЛИС). Это технология, при которой создается микросхема с набором логических элементов, триггеров, иногда оперативной памяти и программируемых электрических связей между ними. При этом программирование FPGA оказывается похоже на разработку электрической схемы, а не программы.

Микросхемы ПЛИС --- это не микропроцессоры, в которых пользовательская программа выполняется последовательно, команда за командой. В ПЛИС реализуется именно электронная схема, состоящая из логики и триггеров.

Проект для ПЛИС может быть разработан, например, в виде принципиальной схемы. Еще существуют специальные языки описания аппаратуры типа Verilog или VHDL.

FPGA обычно используются для обработки сигналов, имеют больше логических элементов и более гибкую архитектуру, чем CPLD. Программа для FPGA хранится в распределённой памяти, которая может быть выполнена как на основе энергозависимых ячеек статического ОЗУ (подобные микросхемы производят, например, фирмы «Xilinx» и «Altera») — в этом случае программа не сохраняется при исчезновении электропитания микросхемы, так и на основе энергонезависимых ячеек flash-памяти или перемычек antifuse (такие микросхемы производит фирма «Actel» и «Lattice Semiconductor») — в этих случаях программа сохраняется при исчезновении электропитания. Если программа хранится в энергозависимой памяти, то при каждом включении питания микросхемы необходимо заново конфигурировать её при помощи начального загрузчика, который может быть встроен и в саму FPGA. Альтернативой ПЛИС FPGA являются более медленные цифровые процессоры обработки сигналов.
## 14. Сравнение FPGA и CPLD
## 15. Structured ASIC
## 16. Сравнение ASIC и FPGA
## 17. Сравнение полностью заказных СБИС и ASIC
## 18. ASIC. Технологические библиотеки
## 19. Исходные данные для процесса логического синтеза ASIC
## 20. Логический синтез ASIC. Типы ограничений
## 21. Оценка длительности периода сигнала тактирования на этапе логического синтеза
## 22. Оценка результатов логического синтеза ASIC
## 23. Оценка динамического энергопотребления после логического синтеза
## 24. Физический синтез ASIC. Типы ограничений
## 25. Этапы синтеза FPGA
## 26. Понятие технологических библиотек применительно к FPGA
## 27. VHDL. Типы данных
Язык VHDL основан на концепции строгой типизации данных, т. е.
любой единице информации в программе обязательно присваивается имя, и
для нее должен быть определен тип. Определение информационной
единицы размещается в разделе деклараций программного модуля, в
котором оно используется, или иерархически предшествующего модуля.
Тип данных определяет набор значений объектов, отнесенных к этому типу,
а также набор допустимых преобразований этих данных. Данные разных
типов несовместимы в одном выражении.

![](https://i.imgur.com/fI5uZE5.png)

Типы `INTEGER` и `REAL` определяют численные данные — целые и
действительные соответственно. Диапазон представления чисел может
зависеть от реализации, но стандартными считаются диапазоны {$-2^{31}+1, +2^{31}-1$} для типа `INTEGER` и {$10^{38}$, $-10^{38}$} для `REAL`.

Данные типа `BIT` могут принимать значения из множества {$0, 1$}. На данных типа `BIT` определены логические операции.

Данные типа `BOOLEAN` также могут принимать два значения: {`TRUE,
FASLSE`}, и на них определены те же операции, что и над данными типа
BIT. Разница между типами `BIT` и `BOOLEAN` состоит в том, что первые
применяются для представления уровней логических сигналов в аппаратуре,
а вторые для представления обобщенных условий, например результатов
сравнения.

Тип `CHARACTER` объединяет все символы, определенные в
используемой операционной системе - буквы, цифры, специальные
символы. В тексте программы символьная константа записывается как
стандартный символ, заключенный в одинарные кавычки ('а', 'b', и т. п.).
Отметим, что символы '0' и '1' имеют двойное назначение — и как символ, и
как логическое значение. В каждом конкретном случае тип определяется по
контексту.

Тип `TIME` - время - служит для задания задержек элементов и времени
приостанова процессов при моделировании. Запись временной константы
имеет вид:
```
<целое> <единица измерения времени>
```
Определены следующие единицы измерения времени:
1. fs - фемтосекунда;
2. ps - пикосекунда;
3. ns - наносекунда;
4. us - микросекунда;
5. ms - миллисекунда;
6. s - секунда.

Над данными типа "время" определены операции отношения, сложения
и вычитания, а также умножения и деления на целое.

Типы `STRING` и `BIT_VECTOR` относятся к агрегатным и фактически
определены как неограниченный массив символов и массив битов
соответственно. Более подробно правила работы с массивами и их
элементами рассмотрены далее. В тексте программы строковая константа
заключается в двойные кавычки.
## 28. VHDL. Отличия сигналов от переменных
**SIGNAL** — это информация, передаваемая между модулями проекта или представляющая входные и выходные данные проектируемого устройства. Сигналу присваиваются свойства изменения во времени.

**VARIABLE** — это вспомогательная информационная единица, используемая для описания внутренних операций в программных блоках. Присвоение значения сигналу отображается знаком `<=`, а переменной — знаком `:=`.

**Сформулируем наиболее существенные различия сигналов и переменных:**
1. Переменные меняют значения сразу после присвоения, и новые значения непосредственно учитываются во всех преобразованиях, записанных в теле процесса
после такого присвоения.
2. Значение сигнала меняется не сразу после выполнения присвоения. Оператору
присваивания сопоставляется некий буфер, называемый контейнером или, чаще,
драйвером сигнала. Оператор присваивания передает новое значение драйверу
сигнала, и лишь после того, как выполнены преобразования во всех процессах,
инициированных общим событием, содержание драйвера передается сигналу. Передача значения сигналу может быть еще более задержана, если оператор присваивания содержит выражение задержки after.
3. Переменная определена только внутри тела процесса, сигнал — во всем архитектурном теле.
4. Переменной можно многократно присваивать значение в теле процесса. Сигнал
внутри одного процесса может иметь только один драйвер, т. е. присвоение значения сигналу может быть выполнено только один раз в теле процесса (на различных несовместимых путях реализации алгоритма могут быть несколько операторов присваивания значений одному сигналу)

## 29. VHDL. Параллельные операторы
## 30. VHDL. Понятие сигналов
Сигналом в VHDL называется объект, который переносит значение и синхронизирующее воздействие от одного процесса к другому (представляя в модели физические линии связи). Каждый сигнал имеет тип, историю прошлых и будущих значений, к которой можно обращаться при помощи атрибутов (см. далее). Также для сигналов определены стандартные логические и арифметические операторы, соответствующие типу сигнала, и два специальных оператора — параллельного присваивания и назначения значения.

```vhdl{style="monokai"}
signal : \идентификатор\{,\идентификатор\}:=[\начальное значение\];
```
где — `\начальное значение\` — выражение, представляющее константу, значение которой принимает сигнал перед первым запуском процесса.
Пример декларации и инициалзации сигнала
```vhdl
SIGNAL B: BIT_VECTOR (3 DOWNTO 0) := "0000";
```

## 31. VHDL. Модельное время
## 32. VHDL. Процессы
## 33. VHDL. Параллельные операторы присваивания
## 34. VHDL. Операторы включения компонентов в модель

## 35. VHDL. Условные операторы
В VHDL определены следующие операторы управления:
* условный оператор `if, elsif`
* оператор выбора `case`

Условный оператор if имеет следующий формат:

```vhdl
# самый простой вариант
if condition then
sequential_statements
end if;

# Вместе с конструкцией else
if condition then
sequential_statements
else
sequential_statements2
end if;

# Если много различных условий elsif
if condition then
sequential_statements
elsif condition2 then
sequential_statements2
else
sequential_statements3
end if;
```

Оператор выбора `case` в зависимости от значения управляющего выражения (которое может быть скалярным типом либо одномерным массивом) выполняет соответствующие группы операторов:

```vhdl
[case_label:] case expression is
when choices1 => sequence_of_statements1
when choices2 => sequence_of_statements2
…
when others => sequence_of_statementsn
end case [case_label];
```

Выражение выбора (choices) может быть как одиночным, так и множественным, альтернативы задаются при помощи оператора |. Примеры использования выражений case приведены ниже:
```vhdl
variable x: Integer range 1 to 3;
-------------
C1: case x is
when 1 => out_1 := 0;
when 2 => out_1 : =1;
when 3 => out_1 : =2;
end case C1;

variable y: BIT_VECTOR (0 to 1)
-------------
C2: case y is
when "00" => out_2 := 0;
when "01" => out_2 := 1;
when "02" => out_2 := 2;
when "03" => out_2 := 3;
end case C2;

type Codes_Of_Operation is (ADD, SUB, MULT, DIV);
variable code_variable: Codes_Of_Operation;
-------------
C3: case code_variable is
when ADD | SUB => operation := 0;
when MULT => operation := 1;
when others => operation := 2;
end case C3;
```

## 36. VHDL. Операторы циклов
Операторы цикла for, while, loop;

По первой схеме итераций цикл, ограниченный ключевыми словами loop и end loop будет выполняться, пока условие \условие\не примет значение false. Причем, это условие проверяется до выполнения цикла и если оно равно false, то цикл не выполняется. В примере:
```vhdl
variable vec: bit_vector(1 to n);
variable or_vec:bit;
variable i:natural;
...
i:=1;  
or_vec:='0';
while i<=n loop
          or_vec:= or_vec or vec(i);
           i:=+1;
end loop;
```

Если необходимо завершить очередную итерацию до ее окончания, то применяют оператор next запуска следующей итерации. В примере:
```vhdl
variable vec: bit_vector(1 to n);
variable numb:natural;
...
numb:=0;
for i in 1 to n loop
    exit when vec(i)='1';
    numb:=numb+1;
end loop;
```

## 37. VHDL. Параметирзация моделей
## 38. VHDL. Generic для параметризации моделей.
Параметризация работает так, как и в высокоуровневых языках программирования: в объявление модуля выносится параметр, который затем используется внутри модуля. Для каждого инстанцирования модуля можно задавать своё значение параметра. Параметры статические, т.е. их значение вычисляется на этапе компиляции/синтеза. Для удобства и упрощения параметры могут иметь значения по умолчанию, в этом случае параметр можно опустить при инстанцировании.

![](https://i.imgur.com/i0c7zkQ.png)

## 39. VHDL. Generate для параметризации моделей.
Если необходимо неоднократно повторить один или несколько параллельных операторов, то используют оператор **generate**.

В отличие от оператора loop, который повторяет в цикле один или несколько последовательных операторов, оператор generate делает несколько копий параллельных операторов, когда параметр оператора пробегает все значения из заданного диапазона.

Пример использования оператора **generate**:
```vhdl
signal t: std_logic_vector(1 to n+1);
    ...
    t(1)<=Di;
    FiFO: for i in 1 to n generate
               U_ TT: FD(C=>CLK, D=>t(i), Q=>t(i+1));
         end generate;
    DO<=t(n+1)
```
**Условный оператор generate.**

Для того чтобы управлять структурой проектируемого устройства используется условный оператор generate. 

В зависимости от условия, заданного булевским выражением, оператор вставляет или нет в структуру устройства узлы, представленные параллельными операторами. Так как это булевское выражение влияет на структуру устройства, оно должно быть статическим. В примере:
```vhdl
RESn: if \подключить_PULLUP\=1 generate
          RES1:for i in DATA_BUS'range generate
                       U_ RES: PULLUP(DATA_BUS(i));
              end generate;
         end generate; 
```


если целое значение `\подключить_PULLUP\` равно 1, то к шине `DATA_BUS` подключаются компоненты нагрузочных резисторов `PULLUP` из библиотеки `UNISIM`.

Направлением научной деятельности автора является синтез структур вычислительных устройств. Поэтому язык VHDL нравится именно тем, что с помощью таких седств, как оператор generate можно программировать структуру устройства в зависимости от параметров ее настройки. Например, можно создать проект универсального цифрового фильтра, число ступеней которого изменяется в зависимости от заданного качества фильтрации.

К сожалению, в языке Verilog нет операторов, аналогичных **generate**
